<%-- val methods: mutable.Buffer[RuntimePropertyInfo] --%>

<%-- Imports  --%>
#import(com.sun.xml.bind.v2.model.runtime.RuntimeClassInfo)
#import(com.sun.xml.bind.v2.model.runtime.RuntimeTypeInfoSet)
#import(com.sun.xml.bind.v2.model.runtime.RuntimePropertyInfo)
#import(com.sun.xml.bind.v2.model.core.{PropertyInfo, NonElement, ElementPropertyInfo, AttributePropertyInfo})
#import(com.sun.xml.bind.v2.model.runtime.{RuntimeClassInfo, RuntimeValuePropertyInfo})
#import(scala.collection.mutable)
#import(scala.collection.JavaConversions)
#import(java.lang.reflect.{ParameterizedType, Type})

<%-- Attributes passed in to the template --%>
<%@ val metadata: me.alanfoster.camelry.codegen.model.MetaData %>
<%@ val other: me.alanfoster.camelry.codegen.model.Other  %>

<%--
   Begin Main Template
--%>

${include("GeneratedWarningTemplate.ssp")}

import com.intellij.util.xml.*;
import com.intellij.util.xml.DomElement;
import org.jetbrains.annotations.*;
import java.util.List;

${include("HeaderTemplate.ssp")}
<%
    // TODO
    val extendClasses =
        if(other.baseClass.nonEmpty) other.baseClass.get.getClazz.getSimpleName :: List("DomElement")
        else List("DomElement")
%>
//@SubTag("${other.xmlName}")
public interface ${other.simpleName} extends ${extendClasses.mkString(", ")}  {
    #for(attribute <- other.attributes)
        #if(attribute.isRequired)
        @Required
        #end
        @NotNull
        GenericAttributeValue<${attribute.getTarget.getType.asInstanceOf[Class[_]].getSimpleName}> get${attribute.getName.capitalize}();
    #end

    #for(element <- other.elements)
        #if(element.isRequired)
        @Required
        #end
        <%-- TODO Investigate the scenario of multiple refs, does this overlap with elementRefs? --%>
        #for(ref <- element.ref)
            <%
                val dataType =
                    if(ref.isInstanceOf[RuntimeClassInfo]) ref.asInstanceOf[RuntimeClassInfo].getClass.getSimpleName
                    else "TODO"
                val name = element.getName.capitalize
            %>
            @NotNull
            #if(element.isCollection)
            List<${dataType}> get${name}s();
            #else
            ${dataType} get${name}();
            #end
        #end
    #end


    #for(elementRef <- other.elementRefs)
    <%
        // Create separated list of all XmlReferences, splitting by an indented new line
        val subTags = JavaConversions.asScalaSet(elementRef.getElements)
                            .map("\"" + _.getElementName.getLocalPart + "\"").grouped(5).map(_.mkString(", "))
                            .mkString("\n\t\t\t\t\t\t")

        val name = elementRef.getName.capitalize
        // TODO Get rid of this specific Type instance casting, and remove it completely before reaching the templates
        val dataType = elementRef.getIndividualType.asInstanceOf[ParameterizedType].getRawType.asInstanceOf[Class[_]].getSimpleName
    %>

        @SubTagsList(${subTags})
        List<${dataType}> getComposite${name}();
    #end

    #if(other.value != null)
        <% val value = other.value %>
        /**
         * Returns the current DomElement value.
         * Originally named as ${value.getName.capitalize}
         */
        @Required
        @NotNull
        ${value.getTarget.getType.asInstanceOf[Class[_]].getSimpleName} getValue();
        /**
         * Sets the current DomElement value.
         * Originally named as ${value.getName.capitalize}
         */
        ${value.getTarget.getType.asInstanceOf[Class[_]].getSimpleName} setValue();
    #end
}